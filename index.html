<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Publication-ready GB Viewer</title>
    <style>
        body { font-family: 'Arial', sans-serif; margin: 20px; background-color: #f4f6f9; color: #333; }
        .container { max-width: 1100px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        h1 { font-size: 1.5rem; border-bottom: 2px solid #0056b3; padding-bottom: 10px; margin-bottom: 20px; }
        
        .upload-section { padding: 30px; border: 2px dashed #0056b3; text-align: center; border-radius: 8px; background-color: #f1f8ff; cursor: pointer; transition: all 0.2s; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .upload-section:hover, .upload-section.dragover { background-color: #cce5ff; border-color: #004085; }
        .btn { background-color: #0056b3; color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold; margin-top: 5px; }
        
        #info-box { margin-top: 15px; padding: 15px; border-radius: 4px; display: none; word-break: break-all; font-size: 1.1em; }
        .error { background-color: #ffe6e6; color: #d93025; border: 1px solid #f5c6c6;}
        .success { background-color: #e6f4ea; color: #1e8e3e; border: 1px solid #ceead6;}
        .loading { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba;}
        
        #controls { display: none; margin-top: 20px; padding: 15px; background-color: #f8f9fa; border: 1px solid #ddd; border-radius: 8px; }
        .controls-header { display: flex; gap: 30px; align-items: center; margin-bottom: 15px; flex-wrap: wrap; }
        .bw-toggle-label { font-weight: bold; cursor: pointer; color: #0056b3; background: #e2f0ff; padding: 6px 12px; border-radius: 6px; border: 1px solid #b8daff; }
        
        .filter-container { max-height: 250px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; background: #fff; border-radius: 4px; display: flex; flex-wrap: wrap; gap: 10px; margin-top: 5px; }
        .filter-item { display: flex; flex-direction: column; gap: 5px; background: #f9f9f9; padding: 8px 12px; border-radius: 6px; border: 1px solid #eee; min-width: 220px; }
        .filter-item label { white-space: nowrap; cursor: pointer; display: flex; align-items: center; gap: 4px; font-size: 0.9em; margin: 0; font-weight: bold; color: #444; }
        .color-palette { display: flex; gap: 4px; align-items: center; }
        .color-swatch { width: 16px; height: 16px; border-radius: 3px; cursor: pointer; border: 1px solid #bbb; box-sizing: border-box; transition: transform 0.1s; }
        .color-swatch:hover { transform: scale(1.1); }
        .color-swatch.selected { border: 2px solid #0056b3; transform: scale(1.15); box-shadow: 0 0 3px rgba(0,86,179,0.5); }
        
        #map-container { margin-top: 20px; overflow-x: auto; border: 1px solid #ddd; background-color: #fff; border-radius: 4px; }
        svg { display: block; }
        
        .draggable-label { cursor: move; user-select: none; }
        .draggable-label:hover { font-weight: bold; fill: #0056b3; }
        .draggable-feature { cursor: ns-resize; }
        .draggable-feature:hover { filter: brightness(0.9); }
        .draggable-scale { cursor: ns-resize; }
        .draggable-scale:hover line, .draggable-scale:hover text { opacity: 0.6; }
        .draggable-feature:active, .draggable-label:active, .draggable-scale:active { cursor: grabbing; }
        
        .bw-mode .feature-polygon { fill: #ffffff !important; stroke: #000000 !important; stroke-width: 2px !important; }
        .bw-mode .feature-polygon[data-is-primer="true"] { fill: none !important; stroke: #000000 !important; stroke-width: 2px !important; }
        
        .tooltip { position: absolute; background: rgba(0, 0, 0, 0.9); color: white; padding: 8px 12px; border-radius: 4px; font-size: 13px; pointer-events: none; display: none; z-index: 100; }
    </style>
</head>
<body>

<div class="container">
    <h1>Benchling .gb Viewer</h1>
    
    <label class="upload-section" id="drop-zone" for="fileInput">
        <span style="font-weight: bold; font-size: 1.1rem; color: #0056b3;">.gb ファイルを選択してください</span>
        <span class="btn">ファイルを選ぶ</span>
        <span style="font-size: 0.9rem; color: #666;">またはここにファイルを直接ドラッグ＆ドロップ</span>
        <input type="file" id="fileInput" accept=".gb,.genbank,.seq" style="display:none;">
    </label>

    <div id="info-box"></div>

    <div id="controls">
        <div class="controls-header">
            <div>
                <strong>文字サイズ: </strong>
                <input type="range" id="fontSizeSlider" min="10" max="24" value="14">
                <span id="fontSizeDisplay">14px</span>
            </div>
            <div>
                <label class="bw-toggle-label">
                    <input type="checkbox" id="bwModeToggle"> 白黒表示モード（論文用）
                </label>
            </div>
        </div>
        <div>
            <strong>表示と色の設定 (チェックを外すと非表示 / 四角をクリックで色変更): </strong>
            <div id="filters"></div>
        </div>
    </div>

    <div id="map-container"></div>
</div>

<div id="tooltip" class="tooltip"></div>

<script>
    const infoBox = document.getElementById('info-box');
    function setStatus(type, msg) {
        infoBox.style.display = 'block';
        infoBox.className = type;
        infoBox.innerHTML = msg;
    }

    window.onerror = function(msg, url, lineNo) {
        setStatus('error', `<strong>システムエラー:</strong><br>${msg}<br>Line: ${lineNo}`);
        return false;
    };

    document.addEventListener("DOMContentLoaded", () => {
        const fileInput = document.getElementById('fileInput');
        const dropZone = document.getElementById('drop-zone');

        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.classList.remove('dragover'); });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                fileInput.files = e.dataTransfer.files;
                handleFile(fileInput.files[0]);
            }
        });

        fileInput.addEventListener('click', function() { this.value = ''; });
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) handleFile(file);
        });

        const bwModeToggle = document.getElementById('bwModeToggle');
        bwModeToggle.addEventListener('change', (e) => {
            if (e.target.checked) document.body.classList.add('bw-mode');
            else document.body.classList.remove('bw-mode');
        });
    });

    function handleFile(file) {
        document.getElementById('controls').style.display = 'none';
        document.getElementById('map-container').innerHTML = '';
        setStatus('loading', 'ファイルを読み込んで解析しています...');

        const reader = new FileReader();
        reader.onerror = () => { setStatus('error', 'ファイルの読み込みに失敗しました。'); };

        reader.onload = function(e) {
            setTimeout(() => {
                try {
                    const text = e.target.result;
                    const parsedData = parseGenBankRobust(text);
                    if (parsedData.length === 0) throw new Error("配列の長さ(LOCUS)が特定できませんでした。");
                    setStatus('success', `<strong>解析成功:</strong> 全長 ${parsedData.length} bp / 認識した特徴 ${parsedData.features.length} 個`);
                    setupControls(parsedData);
                    drawSequenceMap(parsedData);
                } catch (error) {
                    console.error(error);
                    setStatus('error', `<strong>ファイルの解析中にエラーが発生しました:</strong><br>${error.message}`);
                }
            }, 50); 
        };
        reader.readAsText(file);
    }

    // 安定版パーサー
    function parseGenBankRobust(text) {
        const lines = text.split(/\r\n|\n|\r/);
        let length = 0;
        let inFeatures = false;
        let currentFeature = null;
        let isParsingLocation = false;
        const features = [];
        const pastelColors = ['#f8bbd0', '#bbdefb', '#c8e6c9', '#fff9c4', '#e1bee7', '#ffccbc', '#d7ccc8', '#b2dfdb'];

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (line.startsWith('LOCUS')) {
                const bpMatch = line.match(/(\d+)\s*bp/i);
                if (bpMatch) length = parseInt(bpMatch[1], 10);
                else {
                    const parts = line.trim().split(/\s+/);
                    length = parseInt(parts[2], 10); 
                }
            } else if (line.startsWith('FEATURES')) {
                inFeatures = true;
            } else if (line.startsWith('ORIGIN') || line.startsWith('//')) {
                inFeatures = false;
                if (currentFeature) features.push(currentFeature);
                break;
            } else if (inFeatures) {
                if (line.length > 5 && line.charAt(4) === ' ' && line.charAt(5) !== ' ') {
                    if (currentFeature) features.push(currentFeature);
                    const parts = line.trim().split(/\s+/);
                    currentFeature = { type: parts[0], locStr: parts.slice(1).join(''), qualifiers: {} };
                    isParsingLocation = true; 
                } 
                else if (line.indexOf('/') !== -1 && line.trim().startsWith('/')) {
                    isParsingLocation = false; 
                    if (currentFeature) {
                        const qualStr = line.trim().substring(1);
                        const eqIdx = qualStr.indexOf('=');
                        if (eqIdx !== -1) {
                            const key = qualStr.substring(0, eqIdx);
                            const val = qualStr.substring(eqIdx + 1).replace(/(^"|"$)/g, '');
                            currentFeature.qualifiers[key] = val;
                        }
                    }
                } 
                else if (line.startsWith('      ') && currentFeature) {
                    if (isParsingLocation) currentFeature.locStr += line.trim(); 
                }
            }
        }

        const validFeatures = [];
        let colorIndex = 0;
        features.forEach((f, idx) => {
            if (f.type === 'source') return; 
            f.strand = f.locStr.includes('complement') ? -1 : 1;
            const nums = [...f.locStr.matchAll(/\b(\d+)\b/g)].map(m => parseInt(m[1], 10));
            if (nums.length === 0) return;
            f.start = Math.min(...nums);
            f.end = Math.max(...nums);
            if (isNaN(f.start) || isNaN(f.end)) return;
            f.name = f.qualifiers.label || f.qualifiers.ApEinfo_label || f.qualifiers.gene || f.qualifiers.name || f.qualifiers.note || f.type;
            if (f.name.startsWith('sequence:')) f.name = f.type;
            f.id = 'feat-id-' + idx;
            const isPrimer = f.type.toLowerCase().includes('primer');
            if (isPrimer) {
                f.defaultColor = '#000000';
            } else {
                f.defaultColor = pastelColors[colorIndex % pastelColors.length];
                colorIndex++;
            }
            validFeatures.push(f);
        });
        return { length, features: validFeatures };
    }

    function setupControls(data) {
        document.getElementById('controls').style.display = 'block';
        const filtersDiv = document.getElementById('filters');
        filtersDiv.innerHTML = '<div class="filter-container" id="filter-container"></div>';
        const container = document.getElementById('filter-container');
        const availableColors = ['#f8bbd0', '#bbdefb', '#c8e6c9', '#fff9c4', '#e1bee7', '#ffccbc', '#d7ccc8', '#b2dfdb', '#ffffff', '#000000'];

        data.features.forEach(feat => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'filter-item';
            const dispName = feat.name.length > 20 ? feat.name.substring(0, 18) + '...' : feat.name;
            const label = document.createElement('label');
            label.innerHTML = `<input type="checkbox" class="elem-filter" value="${feat.id}" checked> ${dispName} <span style="color:#888; font-weight:normal;">(${feat.type})</span>`;
            const paletteDiv = document.createElement('div');
            paletteDiv.className = 'color-palette';
            availableColors.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                if (color === feat.defaultColor) swatch.classList.add('selected');
                swatch.addEventListener('click', function() {
                    paletteDiv.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                    this.classList.add('selected');
                    const poly = document.querySelector(`polygon[data-id="${feat.id}"]`);
                    if (poly) poly.setAttribute('fill', color);
                });
                paletteDiv.appendChild(swatch);
            });
            itemDiv.appendChild(label);
            itemDiv.appendChild(paletteDiv);
            container.appendChild(itemDiv);
        });

        document.querySelectorAll('.elem-filter').forEach(cb => {
            cb.addEventListener('change', (e) => {
                const id = e.target.value;
                const isChecked = e.target.checked;
                document.querySelectorAll(`[data-id="${id}"]`).forEach(el => el.style.display = isChecked ? 'block' : 'none');
            });
        });

        const slider = document.getElementById('fontSizeSlider');
        const display = document.getElementById('fontSizeDisplay');
        slider.addEventListener('input', (e) => {
            const size = e.target.value;
            display.textContent = `${size}px`;
            document.querySelectorAll('.draggable-label').forEach(el => el.setAttribute('font-size', `${size}px`));
        });
    }

    // 線の追従計算
    function updateLineConnection(line, text) {
        const textX = parseFloat(text.getAttribute("x"));
        const textY = parseFloat(text.getAttribute("y"));
        const topY = parseFloat(line.getAttribute("data-current-y-top"));
        const bottomY = parseFloat(line.getAttribute("data-current-y-bottom"));
        const centerX = parseFloat(line.getAttribute("data-center-x"));
        const centerY = (topY + bottomY) / 2;
        
        line.setAttribute("x1", centerX); 
        line.setAttribute("x2", textX);   
        
        if (textY < centerY) {
            line.setAttribute("y1", topY);
            line.setAttribute("y2", textY + 4); 
        } else {
            line.setAttribute("y1", bottomY);
            line.setAttribute("y2", textY - 14); 
        }
    }

    function drawSequenceMap(data) {
        const container = document.getElementById('map-container');
        container.innerHTML = ''; 
        const svgWidth = 1050;
        const svgHeight = 650; 
        const margin = 50;
        const drawWidth = svgWidth - (margin * 2);
        const safeLength = data.length > 0 ? data.length : 1;
        const scale = drawWidth / safeLength;
        const baseY = 250; 
        const TRACK_HEIGHT = 40;
        const PRIMER_SIZE = 20; // 正三角形のサイズ

        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("width", "100%");
        svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
        svg.setAttribute("id", "main-svg");

        const backbone = document.createElementNS("http://www.w3.org/2000/svg", "line");
        backbone.setAttribute("x1", margin - 20);
        backbone.setAttribute("y1", baseY);
        backbone.setAttribute("x2", margin + drawWidth + 20);
        backbone.setAttribute("y2", baseY);
        backbone.setAttribute("stroke", "#000");
        backbone.setAttribute("stroke-width", "3");
        svg.appendChild(backbone);

        const scaleGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        scaleGroup.setAttribute("class", "draggable-scale");
        const scaleY = 500; 
        const hitbox = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        hitbox.setAttribute("x", margin - 20); hitbox.setAttribute("y", scaleY - 15);
        hitbox.setAttribute("width", drawWidth + 40); hitbox.setAttribute("height", 45);
        hitbox.setAttribute("fill", "transparent");
        scaleGroup.appendChild(hitbox);
        const scaleLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        scaleLine.setAttribute("x1", margin); scaleLine.setAttribute("y1", scaleY);
        scaleLine.setAttribute("x2", margin + drawWidth); scaleLine.setAttribute("y2", scaleY);
        scaleLine.setAttribute("stroke", "#000"); scaleLine.setAttribute("stroke-width", "2");
        scaleGroup.appendChild(scaleLine);

        for (let i = 0; i <= safeLength; i += 1000) {
            const tickX = margin + (i * scale);
            const tick = document.createElementNS("http://www.w3.org/2000/svg", "line");
            tick.setAttribute("x1", tickX); tick.setAttribute("y1", scaleY - 6);
            tick.setAttribute("x2", tickX); tick.setAttribute("y2", scaleY + 6);
            tick.setAttribute("stroke", "#000"); tick.setAttribute("stroke-width", "1.5");
            scaleGroup.appendChild(tick);
            const tickText = document.createElementNS("http://www.w3.org/2000/svg", "text");
            tickText.setAttribute("x", tickX); tickText.setAttribute("y", scaleY + 22);
            tickText.setAttribute("text-anchor", "middle"); tickText.setAttribute("font-size", "12px"); tickText.setAttribute("fill", "#000");
            tickText.textContent = (i === 0 ? "1" : i) + (i + 1000 > safeLength ? " (bp)" : ""); 
            scaleGroup.appendChild(tickText);
        }
        svg.appendChild(scaleGroup);

        const tooltip = document.getElementById('tooltip');
        data.features.sort((a, b) => (b.end - b.start) - (a.end - a.start));

        data.features.forEach((feat, index) => {
            let x1 = margin + (feat.start * scale);
            let x2 = margin + (feat.end * scale);
            const isPrimer = feat.type.toLowerCase().includes('primer');
            const width = Math.max(x2 - x1, 1); 
            
            // 線のX座標の中心を正しく計算（プライマーは三角形の中央、他は図形の中央）
            let centerX;
            if (isPrimer) {
                centerX = feat.strand === 1 ? x2 - (PRIMER_SIZE / 2) : x1 + (PRIMER_SIZE / 2);
            } else {
                centerX = x1 + (width / 2);
            }

            const initialSnappedY = isPrimer ? TRACK_HEIGHT : 0;
            // 描画起点は全て基準の baseY 固定で行う (後でtransformでずらす)
            const yCenter = baseY; 
            const arrowHeight = isPrimer ? PRIMER_SIZE : 28; 
            const yTop = yCenter - (arrowHeight / 2);
            const yBottom = yCenter + (arrowHeight / 2);

            const poly = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            let points = "";
            if (isPrimer) {
                // 正三角形
                if (feat.strand === 1) { 
                    points = `${x2-PRIMER_SIZE},${yTop} ${x2},${yCenter} ${x2-PRIMER_SIZE},${yBottom}`;
                } else { 
                    points = `${x1+PRIMER_SIZE},${yTop} ${x1},${yCenter} ${x1+PRIMER_SIZE},${yBottom}`;
                }
            } else {
                // 通常ブロック
                const headSize = Math.min(15, width);
                if (feat.strand === 1) points = `${x1},${yTop} ${x2-headSize},${yTop} ${x2},${yCenter} ${x2-headSize},${yBottom} ${x1},${yBottom}`;
                else points = `${x2},${yTop} ${x1+headSize},${yTop} ${x1},${yCenter} ${x1+headSize},${yBottom} ${x2},${yBottom}`;
            }

            poly.setAttribute("points", points); 
            poly.setAttribute("data-id", feat.id); 
            poly.setAttribute("data-text-id", `text-${feat.id}`); 
            poly.setAttribute("data-is-primer", isPrimer ? "true" : "false");
            poly.setAttribute("fill", feat.defaultColor); 
            poly.setAttribute("stroke", "#000");
            poly.setAttribute("stroke-width", "2"); 
            poly.setAttribute("class", "draggable-feature feature-polygon");
            
            const lineId = `line-${feat.id}`;
            poly.setAttribute("data-line", lineId);
            
            // 図形を初期位置分ずらす
            const translate = svg.createSVGTransform();
            translate.setTranslate(0, initialSnappedY);
            poly.transform.baseVal.insertItemBefore(translate, 0);
            svg.appendChild(poly);

            // 線の座標も初期位置分ずらす
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("id", lineId); 
            line.setAttribute("data-id", feat.id);
            line.setAttribute("stroke", "#666"); 
            line.setAttribute("stroke-width", "1.5"); 
            line.setAttribute("stroke-dasharray", "4,4"); 
            line.setAttribute("data-center-x", centerX);
            
            line.setAttribute("data-orig-y-top", yTop); 
            line.setAttribute("data-orig-y-bottom", yBottom);
            line.setAttribute("data-current-y-top", yTop + initialSnappedY); 
            line.setAttribute("data-current-y-bottom", yBottom + initialSnappedY);
            svg.appendChild(line);

            // 文字も初期位置分ずらして配置
            const textYOffset = isPrimer ? 60 + (index % 2)*20 : -60 - (index % 3)*20;
            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text.setAttribute("id", `text-${feat.id}`); 
            text.setAttribute("data-id", feat.id);
            text.setAttribute("x", centerX); 
            text.setAttribute("y", baseY + initialSnappedY + textYOffset);
            text.setAttribute("text-anchor", "middle"); 
            text.setAttribute("font-size", "14px"); 
            text.setAttribute("fill", "#000");
            text.setAttribute("class", "draggable-label"); 
            text.setAttribute("data-line", lineId);
            text.textContent = feat.name.length > 25 ? feat.name.substring(0, 23) + '...' : feat.name;
            svg.appendChild(text);

            updateLineConnection(line, text);

            poly.addEventListener('mousemove', (e) => {
                tooltip.style.display = 'block'; tooltip.style.left = e.pageX + 15 + 'px'; tooltip.style.top = e.pageY + 15 + 'px';
                tooltip.innerHTML = `<strong>${feat.name}</strong><br><span style="color:#ddd">${feat.type}</span><br>${feat.start} - ${feat.end} bp`;
            });
            poly.addEventListener('mouseout', () => tooltip.style.display = 'none');
        });
        container.appendChild(svg);
        enableInteractions(svg);
    }

    function enableInteractions(svg) {
        let draggedText = null, draggedFeature = null, draggedScale = null, dragOffset = { x: 0, y: 0 }, initialTranslateY = 0;
        const TRACK_HEIGHT = 40; 
        function getMousePos(e) { const pt = svg.createSVGPoint(); pt.x = e.clientX; pt.y = e.clientY; return pt.matrixTransform(svg.getScreenCTM().inverse()); }

        svg.addEventListener('mousedown', (e) => {
            let target = e.target, scaleTarget = target;
            while (scaleTarget !== svg && scaleTarget) {
                if (scaleTarget.classList && scaleTarget.classList.contains('draggable-scale')) {
                    draggedScale = scaleTarget; const pt = getMousePos(e); dragOffset.y = pt.y; 
                    if (draggedScale.transform.baseVal.numberOfItems === 0) { const translate = svg.createSVGTransform(); translate.setTranslate(0, 0); draggedScale.transform.baseVal.insertItemBefore(translate, 0); }
                    initialTranslateY = draggedScale.transform.baseVal.getItem(0).matrix.f; return; 
                }
                scaleTarget = scaleTarget.parentNode;
            }
            if (target.classList.contains('draggable-label')) {
                draggedText = target; const pt = getMousePos(e); dragOffset.x = pt.x - parseFloat(draggedText.getAttribute('x')); dragOffset.y = pt.y - parseFloat(draggedText.getAttribute('y'));
                draggedText.parentNode.appendChild(draggedText);
            } else if (target.classList.contains('draggable-feature')) {
                draggedFeature = target; const pt = getMousePos(e); dragOffset.y = pt.y; 
                initialTranslateY = draggedFeature.transform.baseVal.getItem(0).matrix.f;
            }
        });

        svg.addEventListener('mousemove', (e) => {
            if (draggedText) {
                e.preventDefault();
                const pt = getMousePos(e); draggedText.setAttribute('x', pt.x - dragOffset.x); draggedText.setAttribute('y', pt.y - dragOffset.y);
                const line = document.getElementById(draggedText.getAttribute('data-line')); if (line) updateLineConnection(line, draggedText);
            } else if (draggedFeature) {
                e.preventDefault();
                const pt = getMousePos(e); const deltaY = pt.y - dragOffset.y;
                const snappedY = Math.round((initialTranslateY + deltaY) / TRACK_HEIGHT) * TRACK_HEIGHT;
                draggedFeature.transform.baseVal.getItem(0).setTranslate(0, snappedY);
                
                const line = document.getElementById(draggedFeature.getAttribute('data-line'));
                const text = document.getElementById(draggedFeature.getAttribute('data-text-id'));
                if (line && text) {
                    // 図形の移動量を点線の計算用座標にも反映させる
                    line.setAttribute('data-current-y-top', parseFloat(line.getAttribute('data-orig-y-top')) + snappedY);
                    line.setAttribute('data-current-y-bottom', parseFloat(line.getAttribute('data-orig-y-bottom')) + snappedY);
                    updateLineConnection(line, text);
                }
            } else if (draggedScale) {
                e.preventDefault();
                const pt = getMousePos(e); draggedScale.transform.baseVal.getItem(0).setTranslate(0, initialTranslateY + pt.y - dragOffset.y);
            }
        });

        const endDrag = () => { draggedText = null; draggedFeature = null; draggedScale = null; };
        svg.addEventListener('mouseup', endDrag); svg.addEventListener('mouseleave', endDrag);
    }
</script>

</body>
</html>